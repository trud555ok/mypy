# множества - неупорядоченая последовательность элементов
# не содержит дубликатов - дубли удаляются
# не поддерживает индексирование

s = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(s, type(s))  # {'pear', 'banana', 'orange', 'apple'} <class 'set'> -- порядок эл меняется, дубли удалены

# print(s[0]) -- ощибка

s2 = set('hello')
print(s2)  # {'o', 'h', 'e', 'l'}

s3 = {i for i in range(1, 11)}
print(s3)  # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} - с цифрами порядок не меняется

s4 = {5, 3, 8, 2, 10, 1}
print(s4)  # {1, 2, 3, 5, 8, 10} -- цифры выстраиваются по порядку и такой порядок не меняется

# пустое множество
# s5 = {} -- неправильно, это пустой словарь
s6 = set()
print(s6)  # set()

a = set('abracadabra')
b = set('alacazam')
print(a, b, sep='\n')
# {'a', 'b', 'd', 'r', 'c'}
# {'l', 'z', 'a', 'm', 'c'}

# операции с множествами - посмотреть методы которые есть для каждой операции

c = a - b  # вычитание - из а убираем все буквы которые есть в b -- result = set1.difference(set2)
print(c)  # {'d', 'b', 'r'}
# обьединение
d = a | b  # буквы которые есть или в а или в b  --- result = set1.union(set2)
print(d)  # {'m', 'z', 'd', 'c', 'a', 'l', 'b', 'r'}
# пересечение
e = a & b  # буквы которые есть и в а и в b  --- result = set1.intersection(set2)
print(e)  # {'a', 'c'}
# множество из элементов
f = a ^ b  # буквы есть в а и в b но не в обоих, те которые дублируются удалились --result = set1.symmetric_difference(set2)
print(f)  # {'m', 'z', 'd', 'b', 'r', 'l'}

# методы с множествами
# set.copy() - вернет копию множества
# set.add(elem) - добавит элем в множество
# my_set.remove(elem) - удаляет элемент с множества, если такого нету то ошибка
# my_set.discard(5) - удаляет элемент из множества, если он есть. Ошибки не вызывает.
# removed_element = my_set.pop() - удаляет и возвращает случайный элемент множества
# my_set.clear() - очищает множество.

# операции сравнения
# issubset(other_set) — проверяет, является ли множество подмножеством.
set1 = {1, 2}
set2 = {1, 2, 3}
result = set1.issubset(set2)  # True
# issuperset(other_set) — проверяет, является ли множество надмножеством.
result = set2.issuperset(set1)  # True
# isdisjoint(other_set) — проверяет, не пересекаются ли множества.
set3 = {4, 5}
result = set1.isdisjoint(set3)  # True - эти множества не пересекаются

# Пример работы:
set1 = {1, 2, 3}
set2 = {3, 4, 5}

# Объединение
print(set1 | set2)  # {1, 2, 3, 4, 5}

# Пересечение
print(set1 & set2)  # {3}

# Разность
print(set1 - set2)  # {1, 2}

# Симметрическая разность
print(set1 ^ set2)  # {1, 2, 4, 5}

# замороженное множество - неизменяемый set()
aa = frozenset('hello')  # нельзя добавить или удалить элемент
# aa.add('test') - ошибка

# Доступ к элементам - только через цикл, так как нельзя добраться по индексу
